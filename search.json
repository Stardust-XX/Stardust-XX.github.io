[{"title":"Introduction to CryptoHack","url":"/2023/07/14/Introduction-to-Cryptohack/","content":"这大概算是我的第一篇博客吧，想通过写博客来记录自己学习的过程，方便自己回顾或者帮助之后的初学者。\n作为CTF初学者，目前最感兴趣且希望深入研究的是密码学-Crypto，校内的学长向我推荐了CryptoHack这个网站，有许多类似闯关的教程，接下来打算以此网站入门Crypto.\n\nFinding Flags\nEach challenge is designed to help introduce you to a new piece of cryptography. Solving a challenge will require you to find a “flag”.\nThese flags will usually be in the format crypto{y0ur_f1rst_fl4g}. The flag format helps you verify that you found the correct solution.\nTry submitting this flag into the form below to solve your first challenge.\n\n第一道没什么好说的，介绍了CTF解题是要找出flag。这里flag已经给出，输入便可通关。\nGreat Snakes\nModern cryptography involves code, and code involves coding. CryptoHack provides a good opportunity to sharpen your skills.\nOf all modern programming languages, Python 3 stands out as ideal for quickly writing cryptographic scripts and attacks. For more information about why we think Python is so great for this, please see the FAQ.\nRun the attached Python script and it will output your flag.\nChallenge files: - great_snakes.py\nResources: - Downloading Python\n\n第二道题则是介绍了Crypto解题需要的工具：Python.\n我们打开附件\nimport sys# import thisif sys.version_info.major == 2:    print(\"You are running Python 2, which is no longer supported. Please update to Python 3.\")ords = [81, 64, 75, 66, 70, 93, 73, 72, 1, 92, 109, 2, 84, 109, 66, 75, 70, 90, 2, 92, 79]print(\"Here is your flag:\")print(\"\".join(chr(o ^ 0x32) for o in ords))\n直接运行即可得到flag：crypto{z3n_0f_pyth0n}\nASCII\nASCII is a 7-bit encoding standard which allows the representation of text using the integers 0-127.\nUsing the below integer array, convert the numbers to their corresponding ASCII characters to obtain a flag.\n[99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125]\nIn Python, the chr() function can be used to convert an ASCII ordinal number to a character (the ord() function does the opposite).\n\n第三题介绍了ASCII码以及Python中的相关函数。\n我们进入Python写一段脚本\narray = [99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125]for i in range (len(array)):    print(chr(array[i]),end='')\n运行可得到flag：crypto{ASCII_pr1nt4bl3}\nHex\nWhen we encrypt something the resulting ciphertext commonly has bytes which are not printable ASCII characters. If we want to share our encrypted data, it’s common to encode it into something more user-friendly and portable across different systems.\nHexadecimal can be used in such a way to represent ASCII strings. First each letter is converted to an ordinal number according to the ASCII table (as in the previous challenge). Then the decimal numbers are converted to base-16 numbers, otherwise known as hexadecimal. The numbers can be combined together, into one long hex string.\nIncluded below is a flag encoded as a hex string. Decode this back into bytes to get the flag.\n63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d\n  In Python, the bytes.fromhex() function can be used to convert hex to bytes. The .hex() instance method can be called on byte strings to get the hex representation.\n\n第四题介绍了Hex，即16进制数。\n在Python中可以使用bytes.fromhex()和.hex()实现bytes类型与hex类型的转换。\n依旧是使用Python\nh='63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d'b=bytes.fromhex(h)print(b)\n运行可得到flag：crypto{You_will_be_working_with_hex_strings_a_lot}\nBase64\nAnother common encoding scheme is Base64, which allows us to represent binary data as an ASCII string using an alphabet of 64 characters. One character of a Base64 string encodes 6 binary digits (bits), and so 4 characters of Base64 encode three 8-bit bytes.\nBase64 is most commonly used online, so binary data such as images can be easily included into HTML or CSS files.\nTake the below hex string, decode it into bytes and then encode it into Base64.\n72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf\n In Python, after importing the base64 module with import base64, you can use the base64.b64encode() function. Remember to decode the hex first as the challenge description states.\n\n第五题介绍了另一个常用的编码：Base64. Base64使用一个64个字符的密码表，即\n\nBase64中1个字符编码6个二进制数字，4个字符编码3个8位字节。\n这道题的题目要求很明确，让我们解码为bytes类型再编码为Base64类型。\n代码如下\nimport base64h='72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf'b=bytes.fromhex(h)b64=base64.b64encode(b)print(b64)\nBytes and Big Integers\nCryptosystems like RSA works on numbers, but messages are made up of characters. How should we convert our messages into numbers so that mathematical operations can be applied?\nThe most common way is to take the ordinal bytes of the message, convert them into hexadecimal, and concatenate. This can be interpreted as a base-16/hexadecimal number, and also represented in base-10/decimal.\nTo illustrate:\n\n message: HELLO ascii bytes: [72, 69, 76, 76, 79] hex bytes: [0x48, 0x45, 0x4c, 0x4c, 0x4f] base-16: 0x48454c4c4f base-10: 310400273487\n\nConvert the following integer back into a message:\n11515195063862318899931685488813747395775516287289682636499965282714637259206269\nPython’s PyCryptodome library implements this with the methods bytes_to_long() and long_to_bytes(). You will first have to install PyCryptodome and import it with from Crypto.Util.number import *. \n\n第六题介绍了bytes与大整数之间的换算，这在后面的RSA加密中也会用到。转换的具体步骤题目中也已经列出，不过我们实际计算只需要一段简单的代码\nfrom Crypto.Util.number import *print(long_to_bytes(11515195063862318899931685488813747395775516287289682636499965282714637259206269))\n运行可得到flag：crypto{3nc0d1n6_4ll_7h3_w4y_d0wn}\nXOR Starter\nXOR is a bitwise operator which returns 0 if the bits are the same, and 1 otherwise. In textbooks the XOR operator is denoted by ⊕, but in most challenges and programming languages you will see the caret ^ used instead.\n\n\n\n\nA\nB\nOutput\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n0\n1\n\n\n1\n1\n0\n\n\n\n\nFor longer binary numbers we XOR bit by bit: 0110 ^ 1010 = 1100. We can XOR integers by first converting the integer from decimal to binary. We can XOR strings by first converting each character to the integer representing the Unicode character.\nGiven the string label, XOR each character with the integer 13. Convert these integers back to a string and submit the flag as crypto{new_string}.\nThe Python pwntools library has a convenient xor() function that can XOR together data of different types and lengths. But first, you may want to implement your own function to solve this.\n\n这一题介绍了异或运算，当两个二进制数值相同时结果为0，不同时结果为1。\n题目中介绍了利用pwntools这个库可以快速进行异或运算，但建议我们第一次还是自己来做。\n既然他都那么说了，我们就先不用这个库。当然实在想用也没关系\n题目说将每一位都与13进行异或，那我们就先将每个字都转成对应的ASCII码，分别与13异或后再转回字符串\nstr='label'for i in range(len(str)):    print(chr(ord(str[i])^13),end='')\n得到答案为crypto{aloha}\nXOR Properties\nIn the last challenge, you saw how XOR worked at the level of bits. In this one, we’re going to cover the properties of the XOR operation and then use them to undo a chain of operations that have encrypted a flag. Gaining an intuition for how this works will help greatly when you come to attacking real cryptosystems later, especially in the block ciphers category.\nThere are four main properties we should consider when we solve challenges using the XOR operator\n\nCommutative: A ⊕ B = B ⊕ AAssociative: A ⊕ (B ⊕ C) = (A ⊕ B) ⊕ CIdentity: A ⊕ 0 = ASelf-Inverse: A ⊕ A = 0\n\nLet’s break this down. Commutative means that the order of the XOR operations is not important. Associative means that a chain of operations can be carried out without order (we do not need to worry about brackets). The identity is 0, so XOR with 0 “does nothing”, and lastly something XOR’d with itself returns zero.\nLet’s put this into practice! Below is a series of outputs where three random keys have been XOR’d together and with the flag. Use the above properties to undo the encryption in the final line to obtain the flag.\nKEY1 = a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313KEY2 ^ KEY1 = 37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1eKEY2 ^ KEY3 = c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1FLAG ^ KEY1 ^ KEY3 ^ KEY2 = 04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf\n\n这一题介绍了异或运算的一些运算性质，更像是一道数学题。\n\n\\begin{align}\na&=KEY1 \\\\\nb&=KEY2\\bigoplus KEY1 \\\\\nc&=KEY2\\bigoplus KEY3 \\\\\nd&=FLAG\\bigoplus KEY1 \\bigoplus KEY2 \\bigoplus KEY3 \\\\\n\\end{align}逐步运算，将KEY消掉，得到\n\nFLAG=d \\bigoplus a\\bigoplus c \\\\接下来就很简单了\nfrom pwn import *a=bytes.fromhex('a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313')c=bytes.fromhex('c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1')d=bytes.fromhex('04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf')print(xor(a,c,d))\n得到答案为：crypto{x0r_i5_ass0c1at1v3}\nFavourite byte\nFor the next few challenges, you’ll use what you’ve just learned to solve some more XOR puzzles.\nI’ve hidden some data using XOR with a single byte, but that byte is a secret. Don’t forget to decode from hex first.\n73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d\n\n这一题没有教什么新东西，撂下一串数字就让我们综合所学知识求解。\n没什么思路，先转成bytes看一眼\n\nb”sbi`d\\x7fk h! O!%O}iOv$f eb!’#Ori’um”\n\n是一串没有什么意义的字符，题目中说这串字符经过XOR加密，但我们并不知道密钥是什么。\n穷举既然如此，我们可以用穷举法依次尝试\nfrom pwn import *h=bytes.fromhex('73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d')for i in range(20):    print(xor(h,i))\nb\"sbi`d\\x7fk h! O!%O}iOv$f eb!'#Ori'um\"b'rchae~j!i !N $N|hNw%g!dc &amp;\"Nsh&amp;tl'b'q`kbf}i\"j#\"M#\\'M\\x7fkMt&amp;d\"g`#%!Mpk%wo'b'pajcg|h#k\"#L\"&amp;L~jLu\\'e#fa\"$ Lqj$vn'b\"wfmd`{o$l%$K%!KymKr b$af%#'Kvm#qi\"b'vgleazn%m$%J$ JxlJs!c%`g$\"&amp;Jwl\"ph'b'udofbym&amp;n\\'&amp;I\\'#I{oIp\"`&amp;cd\\'!%Ito!sk'b'tengcxl\\'o&amp;\\'H&amp;\"HznHq#a\\'be&amp; $Hun rj'b'{jahlwc(`)(G)-GuaG~,n(mj)/+Gza/}e'b'zk`imvb)a()F(,Ft`F\\x7f-o)lk(.*F{`.|d'b'yhcjnua*b+*E+/EwcE|.l*oh+-)Exc-\\x7fg'b'xibkot`+c*+D*.DvbD}/m+ni*,(Dyb,~f'b'\\x7fnelhsg,d-,C-)CqeCz(j,in-+/C~e+ya'b'~odmirf-e,-B,(BpdB{)k-ho,*.B\\x7fd*x`'b'}lgnjqe.f/.A/+AsgAx*h.kl/)-A|g){c'b'|mfokpd/g./@.*@rf@y+i/jm.(,@}f(zb'b'crypto{0x10_15_my_f4v0ur173_by7e}'b'bsxqunz1y01^04^lx^g5w1ts062^cx6d|'b'ap{rvmy2z32]37]o{]d6t2wp351]`{5g\\x7f'b'`qzswlx3{23\\\\26\\\\nz\\\\e7u3vq240\\\\az4f~'\n可以在里面找到crypto{0x10_15_my_f4v0ur173_by7e}，这便是答案了\n倒推从另一个角度想，虽然我们不知道密钥是什么，但我们知道答案一定是以crypto{开头。那由异或的运算性质，将密文的第一位与c进行异或运算，得出的结果就是密钥了\nfrom pwn import *h=bytes.fromhex('73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d')key=h[0]^ord('c')print(key)print(xor(key,h))\n输出结果为\n\n16b’crypto{0x10_15_my_f4v0ur173_by7e}’\n\nYou either know, XOR you don’t\nI’ve encrypted the flag with my secret key, you’ll never be able to guess it.\n0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104\nRemember the flag format and how it might help you in this challenge!\n\n新手村的最后一题，提示中提到了flag形式，那就是暗示我们用倒推法解这道题\n复制上一题的代码\nfrom pwn import *h=bytes.fromhex('0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104')key=h[0]^ord('c')print(key)print(xor(key,h))\n得出结果…\n\n109b’cfLRKis%fKL\\x12JYCz0cjgQ6}SHKL\\x12JYCz0cj\\x13KY&lt;xli’\n\n呃，好像不太对？\n那就把所有已知片段都异或进去看看\nprint(xor(h,b'crypto{'))\n\nb’myXORke+y_Q\\x0bHOMe$~seG8bGURN\\x04DFWg)a|\\x1dTM!an\\x7f’\n\nmyXORke+y……?\n根据语义判断，密钥很可能是myXORkey，代入试试\nprint(xor(h,b'myXORkey'))\n\nb’crypto{1f_y0u_Kn0w_En0uGH_y0u_Kn0w_1t_4ll}’\n\n显然这就是答案了。\n\n新手村的内容到此就结束了，这一章节里学到了像ASCII码、16进制、Base64以及XOR运算等密码学中常用的内容，并且锻炼了一些使用Python解题的能力。下一章等什么时候有空再学吧（\n","categories":["CTF"],"tags":["Crypto"]},{"title":"Modular Arithmetic","url":"/2023/07/23/Modular-Arithmetic/","content":"CryptoHack教程的第二章：模运算。看来这一章整章都是围着数学转了。\n\nGreatest Common Divisor\nThe Greatest Common Divisor (GCD), sometimes known as the highest common factor, is the largest number which divides two positive integers (a,b).\nFor a = 12, b = 8 we can calculate the divisors of a: {1,2,3,4,6,12} and the divisors of b: {1,2,4,8}. Comparing these two, we see that gcd(a,b) = 4.\nNow imagine we take a = 11, b = 17. Both a and b are prime numbers. As a prime number has only itself and 1 as divisors, gcd(a,b) = 1.\nWe say that for any two integers a,b, if gcd(a,b) = 1 then a and b are coprime integers.\nIf a and b are prime, they are also coprime. If a is prime and b &lt; a then a and b are coprime.\nThere are many tools to calculate the GCD of two integers, but for this task we recommend looking up Euclid’s Algorithm.\nTry coding it up; it’s only a couple of lines. Use a = 12, b = 8 to test it.\nNow calculate gcd(a,b) for a = 66528, b = 52920 and enter it below.\n\n第一节GCD，我们熟知的最大公因数。具体就不再赘述了，我们可以用欧几里得算法手算或者写代码\ndef gcd(a, b):    if b &gt; a:        return gcd(b, a)    if a % b == 0:        return b    return gcd(b, a % b)\n计算print(gcd(66528,52920))即可得到答案1512.\nExtended GCD\nLet a and b be positive integers.\nThe extended Euclidean algorithm is an efficient way to find integers u,v such that\na * u + b * v = gcd(a,b)\nUsing the two primes p = 26513, q = 32321, find the integers u,v such that\np * u + q * v = gcd(p,q)\nEnter whichever of u and v is the lower number as the flag.\n\n第二节讲的是扩展的欧几里得算法。\n不管是手算还是写代码都有点麻烦，我的建议是直接用gmpy2库里的gcdext()来计算。\n这里放一个别的大佬写的\ndef egcd(a, b):    x, y, u, v = 0, 1, 1, 0    while a != 0:        q, r = b//a, b % a        m, n = x-u*q, y-v*q        b, a, x, y, u, v = a, r, u, v, m, n    gcd = b    return gcd, x, yprint(egcd(26513,32321))\n结果是10245和-8404，输入-8404即可通过。\nModular Arithmetic 1\nImagine you lean over and look at a cryptographer’s notebook. You see some notes in the margin:\n\n4 + 9 = 15 - 7 = 102 + 3 = 5\n\nAt first you might think they’ve gone mad. Maybe this is why there are so many data leaks nowadays you’d think, but this is nothing more than modular arithmetic modulo 12 (albeit with some sloppy notation).\nYou may not have been calling it modular arithmetic, but you’ve been doing these kinds of calculations since you learnt to tell the time (look again at those equations and think about adding hours).\nFormally, “calculating time” is described by the theory of congruences. We say that two integers are congruent modulo m if a ≡ b mod m.\nAnother way of saying this, is that when we divide the integer a by m, the remainder is b. This tells you that if m divides a (this can be written as m | a) then a ≡ 0 mod m.\nCalculate the following integers:\n\n11 ≡ x mod 68146798528947 ≡ y mod 17\n\nThe solution is the smaller of the two integers.\n\n这一节开始引入了模运算的概念，很容易得到x=5,y=4\n答案是4.\nModular Arithmetic 2\nWe’ll pick up from the last challenge and imagine we’ve picked a modulus p, and we will restrict ourselves to the case when p is prime.\nThe integers modulo p define a field, denoted Fp.\n\nIf the modulus is not prime, the set of integers modulo n define a ring.\n\nA finite field Fp is the set of integers {0,1,...,p-1}, and under both addition and multiplication there is an inverse element b for every element a in the set, such that a + b = 0 and a * b = 1.\n\nNote that the identity element for addition and multiplication is different! This is because the identity when acted with the operator should do nothing: a + 0 = a and a * 1 = a.\n\nLets say we pick p = 17. Calculate 3^17^ mod 17. Now do the same but with 5^17^ mod 17.\nWhat would you expect to get for 7^16^ mod 17? Try calculating that.\nThis interesting fact is known as Fermat’s little theorem. We’ll be needing this (and its generalisations) when we look at RSA cryptography.\nNow take the prime p = 65537. Calculate 273246787654^65536^ mod 65537.\nDid you need a calculator?\n\n这里讲了很多，实际上就是介绍了费马小定理：\n如果是素数，并且不是的倍数，则\n\na^{p-1}\\equiv1 \\mod{p}所以答案很显然就是1.\nModular Inverting\nAs we’ve seen, we can work within a finite field Fp, adding and multiplying elements, and always obtain another element of the field.\nFor all elements g in the field, there exists a unique integer d such that g * d ≡ 1 mod p.\nThis is the multiplicative inverse of g.\nExample: 7 * 8 = 56 ≡ 1 mod 11\nWhat is the inverse element: 3 * d ≡ 1 mod 13?\n\nThink about the little theorem we just worked with. How does this help you find the inverse of an element?\n\n\n这一节讲的是逆元，题目中提示我们用上一节中的定理计算。\n\n\\begin{align}\n3^{12}&\\equiv1 \\mod{13}\\\\\n3*d&\\equiv1 \\mod{13}\n\\end{align}所以\n\n\\begin{align}\n3*d&\\equiv3^{12}\\mod{13}\\\\\nd&\\equiv3^{11}\\mod{13}\n\\end{align}3^11^模13与9同余，答案为9.\nQuadratic Residues\nWe’ve looked at multiplication and division in modular arithmetic, but what does it mean to take the square root modulo an integer?\nFor the following discussion, let’s work modulo p = 29. We can take the integer a = 11 and calculate a2 = 5 mod 29.\nAs a = 11, a2 = 5, we say the square root of 5 is 11.\nThis feels good, but now let’s think about the square root of 18. From the above, we know we need to find some integer a such that a2 = 18\nYour first idea might be to start with a = 1 and loop to a = p-1. In this discussion p isn’t too large and we can quickly look.\nHave a go, try coding this and see what you find. If you’ve coded it right, you’ll find that for all a ∈ Fp* you never find an a such that a2 = 18.\nWhat we are seeing, is that for the elements of F*p, not every element has a square root. In fact, what we find is that for roughly one half of the elements of Fp*, there is no square root.\nWe say that an integer x is a Quadratic Residue if there exists an a such that a2 = x mod p. If there is no such solution, then the integer is a Quadratic Non-Residue.\nIn other words, x is a quadratic residue when it is possible to take the square root of x modulo an integer p.\nIn the below list there are two non-quadratic residues and one quadratic residue.\nFind the quadratic residue and then calculate its square root. Of the two possible roots, submit the smaller one as the flag.\nIf a2 = x then (-a)2 = x. So if x is a quadratic residue in some finite field, then there are always two solutions for a.\n\n这一节讲的是二次剩余与二次非剩余。\n这里用程序遍历每个数依次计算即可，算得6是模29的二次剩余，6模29最小的根为8.\nLegendre Symbol\nIn Quadratic Residues we learnt what it means to take the square root modulo an integer. We also saw that taking a root isn’t always possible.\nIn the previous case when p = 29, even the simplest method of calculating the square root was fast enough, but as p gets larger, this method becomes wildly unreasonable.\nLucky for us, we have a way to check whether an integer is a quadratic residue with a single calculation thanks to Legendre. In the following, we will assume we are working modulo a prime p.\nBefore looking at Legendre’s symbol, let’s take a brief detour to see an interesting property of quadratic (non-)residues.\n\nQuadratic Residue  Quadratic Residue = Quadratic ResidueQuadratic Residue  Quadratic Non-residue = Quadratic Non-residueQuadratic Non-residue * Quadratic Non-residue = Quadratic Residue\n\nSo what’s the trick? The Legendre Symbol gives an efficient way to determine whether an integer is a quadratic residue modulo an odd prime p.\nLegendre’s Symbol: (a / p) ≡ a(p-1)/2 mod p obeys:\n\n(a / p) = 1 if a is a quadratic residue and a ≢ 0 mod p(a / p) = -1 if a is a quadratic non-residue mod p(a / p) = 0 if a ≡ 0 mod p\n\nWhich means given any integer a, calculating pow(a,(p-1)//2,p) is enough to determine if a is a quadratic residue.\nNow for the flag. Given the following 1024 bit prime and 10 integers, find the quadratic residue and then calculate its square root; the square root is your flag. Of the two possible roots, submit the larger one as your answer.\nChallenge files:\n - output.txt\n\n这一节讲了勒让德符号判断一个数是否为模p二次剩余，在gmpy2库中就有一个legendre()可以直接使用。\n先计算一下哪个是平方剩余\nfrom gmpy2 import legendreints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]p = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139for i in range(0,10):    print(legendre(ints[i],p))\nints[5]为1，其余都为-1，所以只有ints[5]为平方剩余。\n费马小定理推导求解在提示中提到可以用费马小定理解\n\n\\begin{align}\na^{p-1}&\\equiv1\\ \\ \\mod{p}\\\\\na^{p+1}&\\equiv a^{2}\\mod{p}\\\\\na^{\\frac{p+1}{2}}&\\equiv a\\ \\ \\mod{p}\n\\end{align}那么很显然，的平方根即\nfrom gmpy2 import powmodp = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139a = 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771print(powmod(a,(p+1)//4,p))\n得到答案\n93291799125366706806545638475797430512104976066103610269938025709952247020061090804870186195285998727680200979853848718589126765742550855954805290253592144209552123062161458584575060939481368210688629862036958857604707468372384278049741369153506182660264876115428251983455344219194133033177700490981696141526\nSageMath列方程求解也可以用SageMath解决。\np=101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139a=85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771PR.&lt;x&gt;=PolynomialRing(Zmod(p))f=x^2-af.roots()\n用SageMath求解它的根，得到两个数，最大的即为答案，与上一个方法相同。\nModular Square Root\nIn Legendre Symbol we introduced a fast way to determine whether a number is a square root modulo a prime. We can go further: there are algorithms for efficiently calculating such roots. The best one in practice is called Tonelli-Shanks, which gets its funny name from the fact that it was first described by an Italian in the 19th century and rediscovered independently by Daniel Shanks in the 1970s.\nAll primes that aren’t 2 are of the form p ≡ 1 mod 4 or p ≡ 3 mod 4, since all odd numbers obey these congruences. As the previous challenge hinted, in the p ≡ 3 mod 4 case, a really simple formula for computing square roots can be derived directly from Fermat’s little theorem. That leaves us still with the p ≡ 1 mod 4 case, so a more general algorithm is required.\nIn a congruence of the form r2 ≡ a mod p, Tonelli-Shanks calculates r.\n\nTonelli-Shanks doesn’t work for composite (non-prime) moduli. Finding square roots modulo composites is computationally equivalent to integer factorization - that is, it’s a hard problem.\n\nThe main use-case for this algorithm is finding elliptic curve co-ordinates. Its operation is somewhat complex so we’re not going to discuss the details, however, implementations are easy to find and Sage has one built-in.\nFind the square root of a modulo the 2048-bit prime p. Give the smaller of the two roots as your answer.\nChallenge files: - output.txt\n\n这一节讲了求模p平方根的方法，叫Tonelli-Shanks但实际上我根本没明白他到底在讲些什么\n实际上计算还是很简单的，Python中有很多库都支持计算模p平方根。\n这里继续用上一题中的SageMath计算\na = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161PR.&lt;x&gt;=PolynomialRing(Zmod(p))f=x^2-af.roots()\n得到答案为\n2362339307683048638327773298580489298932137505520500388338271052053734747862351779647314176817953359071871560041125289919247146074907151612762640868199621186559522068338032600991311882224016021222672243139362180461232646732465848840425458257930887856583379600967761738596782877851318489355679822813155123045705285112099448146426755110160002515592418850432103641815811071548456284263507805589445073657565381850521367969675699760755310784623577076440037747681760302434924932113640061738777601194622244192758024180853916244427254065441962557282572849162772740798989647948645207349737457445440405057156897508368531939120\n","categories":["CTF"],"tags":["Crypto"]}]